package generator

import "text/template"

type ImportStatement struct {
	Name  string
	Alias string
}

type ConnecpyTemplateVariables struct {
	FileName   string
	ModuleName string
	Imports    []ImportStatement
	Services   []*ConnecpyService
}

type ConnecpyService struct {
	Package  string
	Name     string
	FullName string
	Comment  string
	Methods  []*ConnecpyMethod
}

type ConnecpyMethod struct {
	Package          string
	ServiceName      string
	Name             string
	Comment          string
	InputType        string
	OutputType       string
	EndpointType     string
	IdempotencyLevel string
	Stream           bool
	RequestStream    bool
	ResponseStream   bool
	NoSideEffects    bool
}

// ConnecpyTemplate - Template for connecpy server and client
var ConnecpyTemplate = template.Must(template.New("ConnecpyTemplate").Parse(`# -*- coding: utf-8 -*-
# Generated by https://github.com/i2y/connecpy/v2/protoc-gen-connecpy.  DO NOT EDIT!
# source: {{.FileName}}
{{if .Services}}
from typing import AsyncIterator, Iterable, Iterator, Mapping, Protocol

from connecpy.client import ConnecpyClient, ConnecpyClientSync
from connecpy.code import Code
from connecpy.exceptions import ConnecpyException
from connecpy.interceptor import Interceptor, InterceptorSync
from connecpy.method import IdempotencyLevel, MethodInfo
from connecpy.request import Headers, RequestContext
from connecpy.server import ConnecpyASGIApplication, ConnecpyWSGIApplication, Endpoint, EndpointSync

{{- range .Imports }}
import {{.Name}} as {{.Alias}}
{{- end}}
{{- end}}
{{- range .Services}}


class {{.Name}}(Protocol):{{- range .Methods }}
    {{if not .ResponseStream }}async {{end}}def {{.Name}}(self, request: {{if .RequestStream}}AsyncIterator[{{end}}{{.InputType}}{{if .RequestStream}}]{{end}}, ctx: RequestContext) -> {{if .ResponseStream}}AsyncIterator[{{end}}{{.OutputType}}{{if .ResponseStream}}]{{end}}:
        raise ConnecpyException(Code.UNIMPLEMENTED, "Not implemented")
{{ end }}

class {{.Name}}ASGIApplication(ConnecpyASGIApplication):
    def __init__(self, service: {{.Name}}, *, interceptors: Iterable[Interceptor]=(), read_max_bytes: int | None = None):
        super().__init__(
            endpoints={ {{- range .Methods }}
                "/{{.ServiceName}}/{{.Name}}": Endpoint.{{.EndpointType}}(
                    method=MethodInfo(
                        name="{{.Name}}",
                        service_name="{{.ServiceName}}",
                        input={{.InputType}},
                        output={{.OutputType}},
                        idempotency_level=IdempotencyLevel.{{.IdempotencyLevel}},
                    ),
                    function=service.{{.Name}},
                ),{{- end }}
            },
            interceptors=interceptors,
            read_max_bytes=read_max_bytes,
        )

    @property
    def path(self):
        """Returns the URL path to mount the application to when serving multiple applications."""
        return "/{{.FullName}}"


class {{.Name}}Client(ConnecpyClient):{{range .Methods}}
    {{if not .ResponseStream}}async {{end}}def {{.Name}}(
        self,
        request: {{if .RequestStream}}AsyncIterator[{{end}}{{.InputType}}{{if .RequestStream}}]{{end}},
        *,
        headers: Headers | Mapping[str, str] | None = None,
        timeout_ms: int | None = None,
        {{if not .Stream }}{{if .NoSideEffects}}use_get: bool = False,{{end}}{{end}}
    ) -> {{if .ResponseStream}}AsyncIterator[{{.OutputType}}]{{else}}{{.OutputType}}{{end}}:
        return {{if not .ResponseStream }}await {{end}}self.execute_{{.EndpointType}}(
            request=request,
            method=MethodInfo(
                name="{{.Name}}",
                service_name="{{.ServiceName}}",
                input={{.InputType}},
                output={{.OutputType}},
                idempotency_level=IdempotencyLevel.{{.IdempotencyLevel}},
            ),
            headers=headers,
            timeout_ms=timeout_ms,
            {{if not .Stream}}{{if .NoSideEffects}}use_get=use_get,{{end}}{{end}}
        )
{{end}}{{- end }}
{{range .Services}}
class {{.Name}}Sync(Protocol):{{- range .Methods }}
    def {{.Name}}(self, request: {{if .RequestStream}}Iterator[{{end}}{{.InputType}}{{if .RequestStream}}]{{end}}, ctx: RequestContext) -> {{if .ResponseStream}}Iterator[{{end}}{{.OutputType}}{{if .ResponseStream}}]{{end}}:
        raise ConnecpyException(Code.UNIMPLEMENTED, "Not implemented")
{{- end }}


class {{.Name}}WSGIApplication(ConnecpyWSGIApplication):
    def __init__(self, service: {{.Name}}Sync, interceptors: Iterable[InterceptorSync]=(), read_max_bytes: int | None = None):
        super().__init__(
            endpoints={ {{- range .Methods }}
                "/{{.ServiceName}}/{{.Name}}": EndpointSync.{{.EndpointType}}(
                    method=MethodInfo(
                        name="{{.Name}}",
                        service_name="{{.ServiceName}}",
                        input={{.InputType}},
                        output={{.OutputType}},
                        idempotency_level=IdempotencyLevel.{{.IdempotencyLevel}},
                    ),
                    function=service.{{.Name}},
                ),{{- end }}
            },
            interceptors=interceptors,
            read_max_bytes=read_max_bytes,
        )

    @property
    def path(self):
        """Returns the URL path to mount the application to when serving multiple applications."""
        return "/{{.FullName}}"


class {{.Name}}ClientSync(ConnecpyClientSync):{{range .Methods}}
    def {{.Name}}(
        self,
        request: {{if .RequestStream}}Iterator[{{end}}{{.InputType}}{{if .RequestStream}}]{{end}},
        *,
        headers: Headers | Mapping[str, str] | None = None,
        timeout_ms: int | None = None,
        {{if .NoSideEffects}}use_get: bool = False,{{end}}
    ) -> {{if .ResponseStream}}Iterator[{{.OutputType}}]{{else}}{{.OutputType}}{{end}}:
        return self.execute_{{.EndpointType}}(
            request=request,
            method=MethodInfo(
                name="{{.Name}}",
                service_name="{{.ServiceName}}",
                input={{.InputType}},
                output={{.OutputType}},
                idempotency_level=IdempotencyLevel.{{.IdempotencyLevel}},
            ),
            headers=headers,
            timeout_ms=timeout_ms,
            {{if not .Stream}}{{if .NoSideEffects}}use_get=use_get,{{end}}{{end}}
        )
{{end}}{{end}}`))
