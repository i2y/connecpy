package generator

import "text/template"

type ImportStatement struct {
	Name     string
	Alias    string
	Relative bool
	IsLocal  bool // true for local imports (like example.*), false for third-party (like google.*)
}

type ConnecpyTemplateVariables struct {
	FileName   string
	ModuleName string
	Imports    []ImportStatement
	Services   []*ConnecpyService
}

type ConnecpyService struct {
	Package  string
	Name     string
	FullName string
	Comment  string
	Methods  []*ConnecpyMethod
}

type ConnecpyMethod struct {
	Package          string
	ServiceName      string
	Name             string
	PythonName       string
	Comment          string
	InputType        string
	OutputType       string
	EndpointType     string
	IdempotencyLevel string
	Stream           bool
	RequestStream    bool
	ResponseStream   bool
	NoSideEffects    bool
}

// ConnecpyTemplate - Template for connecpy server and client
var ConnecpyTemplate = template.Must(template.New("ConnecpyTemplate").Parse(`# Generated by https://github.com/i2y/connecpy/v2/protoc-gen-connecpy.  DO NOT EDIT!
# source: {{.FileName}}
{{if .Services}}
import importlib
from collections.abc import AsyncIterator, Iterable, Iterator, Mapping
from typing import Any, ClassVar, Protocol
{{- range .Imports }}
{{- if not .IsLocal }}

{{if .Relative}}from . import {{.Name}}{{else}}import {{.Name}}{{end}} as {{.Alias}}
{{- end}}
{{- end}}
from connecpy.client import ConnecpyClient, ConnecpyClientSync
from connecpy.code import Code
from connecpy.exceptions import ConnecpyException
from connecpy.interceptor import Interceptor, InterceptorSync
from connecpy.method import IdempotencyLevel, MethodInfo
from connecpy.request import Headers, RequestContext
from connecpy.server import (
    ConnecpyASGIApplication,
    ConnecpyWSGIApplication,
    Endpoint,
    EndpointSync,
)
{{- range .Imports }}
{{- if .IsLocal }}

{{if .Relative}}from . import {{.Name}}{{else}}import {{.Name}}{{end}} as {{.Alias}}
{{- end}}
{{- end}}
{{- end}}
{{- range .Services}}


class {{.Name}}(Protocol):
    """Service protocol for {{.Name}}."""

    _service_info: ClassVar[dict] = {
        "name": "{{.FullName}}",
        "methods": { {{- range .Methods }}
            "{{.PythonName}}": MethodInfo(
                name="{{.Name}}",
                service_name="{{.ServiceName}}",
                input={{.InputType}},
                output={{.OutputType}},
                idempotency_level=IdempotencyLevel.{{.IdempotencyLevel}},
            ),{{- end }}
        }
    }
    {{- range .Methods }}
    {{if not .ResponseStream }}async {{end}}def {{.PythonName}}(self, request: {{if .RequestStream}}AsyncIterator[{{end}}{{.InputType}}{{if .RequestStream}}]{{end}}, ctx: RequestContext) -> {{if .ResponseStream}}AsyncIterator[{{end}}{{.OutputType}}{{if .ResponseStream}}]{{end}}:
        raise ConnecpyException(Code.UNIMPLEMENTED, "Not implemented")
{{ end }}

class {{.Name}}ASGIApplication(ConnecpyASGIApplication):
    def __init__(self, service: {{.Name}}, *, interceptors: Iterable[Interceptor]=(), read_max_bytes: int | None = None):
        super().__init__(
            endpoints={ {{- range .Methods }}
                "/{{.ServiceName}}/{{.Name}}": Endpoint.{{.EndpointType}}(
                    method=MethodInfo(
                        name="{{.Name}}",
                        service_name="{{.ServiceName}}",
                        input={{.InputType}},
                        output={{.OutputType}},
                        idempotency_level=IdempotencyLevel.{{.IdempotencyLevel}},
                    ),
                    function=service.{{.PythonName}},
                ),{{- end }}
            },
            interceptors=interceptors,
            read_max_bytes=read_max_bytes,
        )

    @property
    def path(self):
        """Returns the URL path to mount the application to when serving multiple applications."""
        return "/{{.FullName}}"


class {{.Name}}Client(ConnecpyClient):{{range .Methods}}
    {{if not .ResponseStream}}async {{end}}def {{.PythonName}}(
        self,
        request: {{if .RequestStream}}AsyncIterator[{{end}}{{.InputType}}{{if .RequestStream}}]{{end}},
        *,
        headers: Headers | Mapping[str, str] | None = None,
        timeout_ms: int | None = None,
        {{- if .NoSideEffects}}
        _use_get: bool = False,
        {{- end}}
    ) -> {{if .ResponseStream}}AsyncIterator[{{.OutputType}}]{{else}}{{.OutputType}}{{end}}:
        return {{if not .ResponseStream }}await {{end}}self.execute_{{.EndpointType}}(
            request=request,
            method=MethodInfo(
                name="{{.Name}}",
                service_name="{{.ServiceName}}",
                input={{.InputType}},
                output={{.OutputType}},
                idempotency_level=IdempotencyLevel.{{.IdempotencyLevel}},
            ),
            headers=headers,
            timeout_ms=timeout_ms,
            {{- if .NoSideEffects}}
            use_get=_use_get,
            {{- end}}
        )
{{end}}{{- end }}
{{range .Services}}
class {{.Name}}Sync(Protocol):
    """Synchronous service protocol for {{.Name}}."""

    _service_info: ClassVar[dict] = {
        "name": "{{.FullName}}",
        "methods": { {{- range .Methods }}
            "{{.PythonName}}": MethodInfo(
                name="{{.Name}}",
                service_name="{{.ServiceName}}",
                input={{.InputType}},
                output={{.OutputType}},
                idempotency_level=IdempotencyLevel.{{.IdempotencyLevel}},
            ),{{- end }}
        }
    }
    {{- range .Methods }}
    def {{.PythonName}}(self, request: {{if .RequestStream}}Iterator[{{end}}{{.InputType}}{{if .RequestStream}}]{{end}}, ctx: RequestContext) -> {{if .ResponseStream}}Iterator[{{end}}{{.OutputType}}{{if .ResponseStream}}]{{end}}:
        raise ConnecpyException(Code.UNIMPLEMENTED, "Not implemented")
{{- end }}


class {{.Name}}WSGIApplication(ConnecpyWSGIApplication):
    def __init__(self, service: {{.Name}}Sync, interceptors: Iterable[InterceptorSync]=(), read_max_bytes: int | None = None):
        super().__init__(
            endpoints={ {{- range .Methods }}
                "/{{.ServiceName}}/{{.Name}}": EndpointSync.{{.EndpointType}}(
                    method=MethodInfo(
                        name="{{.Name}}",
                        service_name="{{.ServiceName}}",
                        input={{.InputType}},
                        output={{.OutputType}},
                        idempotency_level=IdempotencyLevel.{{.IdempotencyLevel}},
                    ),
                    function=service.{{.PythonName}},
                ),{{- end }}
            },
            interceptors=interceptors,
            read_max_bytes=read_max_bytes,
        )

    @property
    def path(self):
        """Returns the URL path to mount the application to when serving multiple applications."""
        return "/{{.FullName}}"


class {{.Name}}ClientSync(ConnecpyClientSync):{{range .Methods}}
    def {{.PythonName}}(
        self,
        request: {{if .RequestStream}}Iterator[{{end}}{{.InputType}}{{if .RequestStream}}]{{end}},
        *,
        headers: Headers | Mapping[str, str] | None = None,
        timeout_ms: int | None = None,
        {{- if .NoSideEffects}}
        _use_get: bool = False,
        {{- end}}
    ) -> {{if .ResponseStream}}Iterator[{{.OutputType}}]{{else}}{{.OutputType}}{{end}}:
        return self.execute_{{.EndpointType}}(
            request=request,
            method=MethodInfo(
                name="{{.Name}}",
                service_name="{{.ServiceName}}",
                input={{.InputType}},
                output={{.OutputType}},
                idempotency_level=IdempotencyLevel.{{.IdempotencyLevel}},
            ),
            headers=headers,
            timeout_ms=timeout_ms,
            {{- if .NoSideEffects}}
            use_get=_use_get,
            {{- end}}
        )
{{end}}

# Client Protocol types for type-safe transport API
class {{.Name}}ClientProtocol(Protocol):
    """Protocol defining the client interface for {{.Name}}."""
    {{- range .Methods}}
    {{if not .ResponseStream}}async {{end}}def {{.PythonName}}(
        self,
        request: {{if .RequestStream}}AsyncIterator[{{end}}{{.InputType}}{{if .RequestStream}}]{{end}},
        *,
        headers: Mapping[str, str] | None = None,
        timeout_ms: int | None = None,
        {{- if .NoSideEffects}}
        _use_get: bool = False,
        {{- end}}
    ) -> {{if .ResponseStream}}AsyncIterator[{{.OutputType}}]{{else}}{{.OutputType}}{{end}}: ...
{{- end}}


class {{.Name}}ClientSyncProtocol(Protocol):
    """Protocol defining the synchronous client interface for {{.Name}}."""
    {{- range .Methods}}
    def {{.PythonName}}(
        self,
        request: {{if .RequestStream}}Iterator[{{end}}{{.InputType}}{{if .RequestStream}}]{{end}},
        *,
        headers: Mapping[str, str] | None = None,
        timeout_ms: int | None = None,
        {{- if .NoSideEffects}}
        _use_get: bool = False,
        {{- end}}
    ) -> {{if .ResponseStream}}Iterator[{{.OutputType}}]{{else}}{{.OutputType}}{{end}}: ...
{{- end}}


class {{.Name}}GrpcWrapper:
    """Async gRPC stub wrapper implementing {{.Name}}ClientProtocol."""

    def __init__(self, stub: Any) -> None:
        """Initialize with a gRPC async stub."""
        self._stub = stub
    {{- range .Methods}}

    {{if not .ResponseStream}}async {{end}}def {{.PythonName}}(
        self,
        request: {{if .RequestStream}}AsyncIterator[{{end}}{{.InputType}}{{if .RequestStream}}]{{end}},
        *,
        headers: Mapping[str, str] | None = None,
        timeout_ms: int | None = None,
        {{- if .NoSideEffects}}
        _use_get: bool = False,
        {{- end}}
    ) -> {{if .ResponseStream}}AsyncIterator[{{.OutputType}}]{{else}}{{.OutputType}}{{end}}:
        """Call {{.Name}} via gRPC."""
        metadata = [(k.lower(), v) for k, v in (headers or {}).items()]
        timeout = timeout_ms / 1000.0 if timeout_ms else None
        {{- if .RequestStream}}
        # Client streaming or bidi streaming
        {{- if .ResponseStream}}
        # Bidi streaming - return the stream directly
        return self._stub.{{.Name}}(request, metadata=metadata, timeout=timeout)
        {{- else}}
        # Client streaming - await the result
        return await self._stub.{{.Name}}(request, metadata=metadata, timeout=timeout)
        {{- end}}
        {{- else}}{{- if .ResponseStream}}
        # Server streaming - return the stream directly
        return self._stub.{{.Name}}(request, metadata=metadata, timeout=timeout)
        {{- else}}
        # Unary - await the result
        return await self._stub.{{.Name}}(request, metadata=metadata, timeout=timeout)
        {{- end}}{{- end}}
    {{- end}}


class {{.Name}}GrpcWrapperSync:
    """Sync gRPC stub wrapper implementing {{.Name}}ClientSyncProtocol."""

    def __init__(self, stub: Any) -> None:
        """Initialize with a gRPC sync stub."""
        self._stub = stub
    {{- range .Methods}}

    def {{.PythonName}}(
        self,
        request: {{if .RequestStream}}Iterator[{{end}}{{.InputType}}{{if .RequestStream}}]{{end}},
        *,
        headers: Mapping[str, str] | None = None,
        timeout_ms: int | None = None,
        {{- if .NoSideEffects}}
        _use_get: bool = False,
        {{- end}}
    ) -> {{if .ResponseStream}}Iterator[{{.OutputType}}]{{else}}{{.OutputType}}{{end}}:
        """Call {{.Name}} via gRPC."""
        metadata = [(k.lower(), v) for k, v in (headers or {}).items()]
        timeout = timeout_ms / 1000.0 if timeout_ms else None
        return self._stub.{{.Name}}(request, metadata=metadata, timeout=timeout)
    {{- end}}


def create_client(
    transport: Any,  # Union[ConnectTransportAsync, GrpcTransportAsync]
) -> {{.Name}}ClientProtocol:
    """Create an async {{.Name}} client with the specified transport.

    Args:
        transport: The transport to use (ConnectTransportAsync or GrpcTransportAsync)

    Returns:
        A client implementing {{.Name}}ClientProtocol
    """
    # Avoid circular imports by importing here
    from connecpy.transport.connect_async import ConnectTransportAsync  # noqa: PLC0415
    from connecpy.transport.grpc_async import GrpcTransportAsync  # noqa: PLC0415

    if isinstance(transport, ConnectTransportAsync):
        return {{.Name}}Client(
            address=transport.address,
            proto_json=transport.proto_json,
            accept_compression=transport.accept_compression,
            send_compression=transport.send_compression,
            timeout_ms=transport.timeout_ms,
            read_max_bytes=transport.read_max_bytes,
            interceptors=transport.interceptors,
            session=transport.session,
        )
    if isinstance(transport, GrpcTransportAsync):
        # Import grpc stub
        module_parts = __name__.split(".")
        if module_parts[-1].endswith("_connecpy"):
            base_name = module_parts[-1][:-9]  # Remove "_connecpy"
            module_parts[-1] = f"{base_name}_pb2_grpc"
            grpc_module_name = ".".join(module_parts)
        else:
            grpc_module_name = f"{__name__}_pb2_grpc"

        grpc_mod = importlib.import_module(grpc_module_name)
        stub_class = getattr(grpc_mod, "{{.Name}}Stub")  # noqa: B009
        stub = stub_class(transport._channel)  # noqa: SLF001
        return {{.Name}}GrpcWrapper(stub)

    error_msg = f"Unsupported transport type: {type(transport)}"
    raise TypeError(error_msg)


def create_client_sync(
    transport: Any,  # Union[ConnectTransport, GrpcTransport]
) -> {{.Name}}ClientSyncProtocol:
    """Create a sync {{.Name}} client with the specified transport.

    Args:
        transport: The transport to use (ConnectTransport or GrpcTransport)

    Returns:
        A client implementing {{.Name}}ClientSyncProtocol
    """
    # Avoid circular imports by importing here
    from connecpy.transport.connect import ConnectTransport  # noqa: PLC0415
    from connecpy.transport.grpc import GrpcTransport  # noqa: PLC0415

    if isinstance(transport, ConnectTransport):
        return {{.Name}}ClientSync(
            address=transport.address,
            proto_json=transport.proto_json,
            accept_compression=transport.accept_compression,
            send_compression=transport.send_compression,
            timeout_ms=transport.timeout_ms,
            read_max_bytes=transport.read_max_bytes,
            interceptors=transport.interceptors,
            session=transport.session,
        )
    if isinstance(transport, GrpcTransport):
        # Import grpc stub
        module_parts = __name__.split(".")
        if module_parts[-1].endswith("_connecpy"):
            base_name = module_parts[-1][:-9]  # Remove "_connecpy"
            module_parts[-1] = f"{base_name}_pb2_grpc"
            grpc_module_name = ".".join(module_parts)
        else:
            grpc_module_name = f"{__name__}_pb2_grpc"

        grpc_mod = importlib.import_module(grpc_module_name)
        stub_class = getattr(grpc_mod, "{{.Name}}Stub")  # noqa: B009
        stub = stub_class(transport._channel)  # noqa: SLF001
        return {{.Name}}GrpcWrapperSync(stub)

    error_msg = f"Unsupported transport type: {type(transport)}"
    raise TypeError(error_msg)
{{- end}}
`))
