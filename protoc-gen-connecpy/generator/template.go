package generator

import "text/template"

type ImportStatement struct {
	Name  string
	Alias string
}

type ConnecpyTemplateVariables struct {
	FileName   string
	ModuleName string
	Imports    []ImportStatement
	Services   []*ConnecpyService
}

type ConnecpyService struct {
	Package string
	Name    string
	Comment string
	Methods []*ConnecpyMethod
}

type ConnecpyMethod struct {
	Package       string
	ServiceName   string
	Name          string
	Comment       string
	InputType     string
	OutputType    string
	NoSideEffects bool
}

// ConnecpyTemplate - Template for connecpy server and client
var ConnecpyTemplate = template.Must(template.New("ConnecpyTemplate").Parse(`# -*- coding: utf-8 -*-
# Generated by https://github.com/i2y/connecpy/protoc-gen-connecpy.  DO NOT EDIT!
# source: {{.FileName}}
{{if .Services}}
from typing import Iterable, Mapping, Protocol

import httpx

from connecpy.client import ConnecpyClient, ConnecpyClientSync
from connecpy.code import Code
from connecpy.exceptions import ConnecpyException
from connecpy.headers import Headers
from connecpy.server import ConnecpyASGIApplication, ConnecpyWSGIApplication, Endpoint, ServerInterceptor, ServiceContext

{{- range .Imports }}
import {{.Name}} as {{.Alias}}
{{- end}}
{{- end}}
{{- range .Services}}


class {{.Name}}(Protocol):{{- range .Methods }}
    async def {{.Name}}(self, req: {{.InputType}}, ctx: ServiceContext) -> {{.OutputType}}:
        raise ConnecpyException(Code.UNIMPLEMENTED, "Not implemented")
{{ end }}

class {{.Name}}ASGIApplication(ConnecpyASGIApplication):
    def __init__(self, service: {{.Name}}, *, interceptors: Iterable[ServerInterceptor]=(), max_receive_message_length=1024 * 100 * 100):
        super().__init__(
            path="/{{.Package}}.{{.Name}}",
            endpoints={ {{- range .Methods }}
                "/{{.Package}}.{{.ServiceName}}/{{.Name}}": Endpoint[{{.InputType}}, {{.OutputType}}](
                    service_name="{{.ServiceName}}",
                    name="{{.Name}}",
                    function=getattr(service, "{{.Name}}"),
                    input={{.InputType}},
                    output={{.OutputType}},
                    allowed_methods={{if .NoSideEffects}}("GET", "POST"){{else}}("POST",){{end}},
                ),{{- end }}
            },
            interceptors=interceptors,
             max_receive_message_length=max_receive_message_length
        )

    @property
    def service_name(self):
        return "{{.Package}}.{{.Name}}"


class {{.Name}}Client(ConnecpyClient):{{range .Methods}}
    async def {{.Name}}(
        self,
        request: {{.InputType}},
        *,
        headers: Headers | Mapping[str, str] | None = None,
        timeout_ms: int | None = None,
        server_path_prefix: str = "",
        session: httpx.AsyncClient | None = None,
        {{if .NoSideEffects}}use_get: bool = False,{{end}}
    ) -> {{.OutputType}}:
        {{if .NoSideEffects}}method = "GET" if use_get else "POST"{{else}}method = "POST"{{end}}
        return await self._make_request(
            url=f"{server_path_prefix}/{{.Package}}.{{.ServiceName}}/{{.Name}}",
            method=method,
            headers=headers,
            request=request,
            timeout_ms=timeout_ms,
            response_class={{.OutputType}},
            session=session,
        )
{{end}}{{- end }}
{{range .Services}}
class {{.Name}}Sync(Protocol):{{- range .Methods }}
    def {{.Name}}(self, req: {{.InputType}}, ctx: ServiceContext) -> {{.OutputType}}:
        raise ConnecpyException(Code.UNIMPLEMENTED, "Not implemented")
{{- end }}


class {{.Name}}WSGIApplication(ConnecpyWSGIApplication):
    def __init__(self, service: {{.Name}}Sync):
        super().__init__(
            path="/{{.Package}}.{{.Name}}",
            endpoints={ {{- range .Methods }}
                "/{{.Package}}.{{.ServiceName}}/{{.Name}}": Endpoint[{{.InputType}}, {{.OutputType}}](
                    service_name="{{.ServiceName}}",
                    name="{{.Name}}",
                    function=getattr(service, "{{.Name}}"),
                    input={{.InputType}},
                    output={{.OutputType}},
                    allowed_methods={{if .NoSideEffects}}("GET", "POST"){{else}}("POST",){{end}},
                ),{{- end }}
            }
        )

    @property
    def service_name(self):
        return "{{.Package}}.{{.Name}}"


class {{.Name}}ClientSync(ConnecpyClientSync):{{range .Methods}}
    def {{.Name}}(
        self,
        request: {{.InputType}},
        *,
        headers: Headers | Mapping[str, str] | None = None,
        timeout_ms: int | None = None,
        server_path_prefix: str = "",
        {{if .NoSideEffects}}use_get: bool = False,{{end}}
    ) -> {{.OutputType}}:
        {{if .NoSideEffects}}method = "GET" if use_get else "POST"{{else}}method = "POST"{{end}}
        return self._make_request(
            url=f"{server_path_prefix}/{{.Package}}.{{.ServiceName}}/{{.Name}}",
            method=method,
            headers=headers,
            timeout_ms=timeout_ms,
            request=request,
            response_class={{.OutputType}},
        )
{{end}}{{end}}`))
