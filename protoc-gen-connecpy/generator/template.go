package generator

import "text/template"

type ImportStatement struct {
	Name  string
	Alias string
}

type ConnecpyTemplateVariables struct {
	FileName   string
	ModuleName string
	Imports    []ImportStatement
	Services   []*ConnecpyService
}

type ConnecpyService struct {
	Package string
	Name    string
	Comment string
	Methods []*ConnecpyMethod
}

type ConnecpyMethod struct {
	Package        string
	ServiceName    string
	Name           string
	Comment        string
	InputType      string
	OutputType     string
	EndpointType   string
	Stream         bool
	RequestStream  bool
	ResponseStream bool
	NoSideEffects  bool
}

// ConnecpyTemplate - Template for connecpy server and client
var ConnecpyTemplate = template.Must(template.New("ConnecpyTemplate").Parse(`# -*- coding: utf-8 -*-
# Generated by https://github.com/i2y/connecpy/v2/protoc-gen-connecpy.  DO NOT EDIT!
# source: {{.FileName}}
{{if .Services}}
from typing import AsyncIterator, Iterable, Iterator, Mapping, Protocol

from connecpy.client import ConnecpyClient, ConnecpyClientSync, ResponseStream, ResponseStreamSync
from connecpy.code import Code
from connecpy.exceptions import ConnecpyException
from connecpy.headers import Headers
from connecpy.server import ConnecpyASGIApplication, ConnecpyWSGIApplication, Endpoint, EndpointSync, ServerInterceptor, ServiceContext

{{- range .Imports }}
import {{.Name}} as {{.Alias}}
{{- end}}
{{- end}}
{{- range .Services}}


class {{.Name}}(Protocol):{{- range .Methods }}
    {{if not .ResponseStream }}async {{end}}def {{.Name}}(self, req: {{if .RequestStream}}AsyncIterator[{{end}}{{.InputType}}{{if .RequestStream}}]{{end}}, ctx: ServiceContext) -> {{if .ResponseStream}}AsyncIterator[{{end}}{{.OutputType}}{{if .ResponseStream}}]{{end}}:
        raise ConnecpyException(Code.UNIMPLEMENTED, "Not implemented")
{{ end }}

class {{.Name}}ASGIApplication(ConnecpyASGIApplication):
    def __init__(self, service: {{.Name}}, *, interceptors: Iterable[ServerInterceptor]=(), read_max_bytes: int | None = None):
        super().__init__(
            endpoints={ {{- range .Methods }}
                "/{{.Package}}.{{.ServiceName}}/{{.Name}}": Endpoint[{{.InputType}}, {{.OutputType}}].{{.EndpointType}}(
                    service_name="{{.ServiceName}}",
                    name="{{.Name}}",
                    function=service.{{.Name}},
                    input={{.InputType}},
                    output={{.OutputType}},
                    {{- if not .Stream }}allowed_methods={{if .NoSideEffects}}("GET", "POST"){{else}}("POST",){{end}},{{end}}
                ),{{- end }}
            },
            interceptors=interceptors,
            read_max_bytes=read_max_bytes,
        )

    @property
    def path(self):
        """Returns the URL path to mount the application to when serving multiple applications."""
        return "/{{.Package}}.{{.Name}}"


class {{.Name}}Client(ConnecpyClient):{{range .Methods}}
    async def {{.Name}}(
        self,
        request: {{if .RequestStream}}AsyncIterator[{{end}}{{.InputType}}{{if .RequestStream}}]{{end}},
        *,
        headers: Headers | Mapping[str, str] | None = None,
        timeout_ms: int | None = None,
        {{if .NoSideEffects}}use_get: bool = False,{{end}}
    ) -> {{if .ResponseStream}}ResponseStream[{{.OutputType}}]{{else}}{{.OutputType}}{{end}}:
        {{if .Stream -}}
        res = await self._make_request_stream(
            url="/{{.Package}}.{{.ServiceName}}/{{.Name}}",
            headers=headers,
            request=request,
            timeout_ms=timeout_ms,
            response_class={{.OutputType}},
        )
        {{if .ResponseStream -}}
        return res
        {{else -}}
        return await self._consume_single_response(res)
        {{end}}
        {{else -}}
        return await self._make_request(
            url="/{{.Package}}.{{.ServiceName}}/{{.Name}}",
            method={{if .NoSideEffects}}"GET" if use_get else "POST"{{else}}"POST"{{end}},
            headers=headers,
            request=request,
            timeout_ms=timeout_ms,
            response_class={{.OutputType}},
        )
        {{end}}
{{end}}{{- end }}
{{range .Services}}
class {{.Name}}Sync(Protocol):{{- range .Methods }}
    def {{.Name}}(self, req: {{if .RequestStream}}Iterator[{{end}}{{.InputType}}{{if .RequestStream}}]{{end}}, ctx: ServiceContext) -> {{if .ResponseStream}}Iterator[{{end}}{{.OutputType}}{{if .ResponseStream}}]{{end}}:
        raise ConnecpyException(Code.UNIMPLEMENTED, "Not implemented")
{{- end }}


class {{.Name}}WSGIApplication(ConnecpyWSGIApplication):
    def __init__(self, service: {{.Name}}Sync, read_max_bytes: int | None = None):
        super().__init__(
            endpoints={ {{- range .Methods }}
                "/{{.Package}}.{{.ServiceName}}/{{.Name}}": EndpointSync[{{.InputType}}, {{.OutputType}}].{{.EndpointType}}(
                    service_name="{{.ServiceName}}",
                    name="{{.Name}}",
                    function=service.{{.Name}},
                    input={{.InputType}},
                    output={{.OutputType}},
                    {{- if not .Stream }}allowed_methods={{if .NoSideEffects}}("GET", "POST"){{else}}("POST",){{end}},{{end}}
                ),{{- end }}
            },
            read_max_bytes=read_max_bytes,
        )

    @property
    def path(self):
        """Returns the URL path to mount the application to when serving multiple applications."""
        return "/{{.Package}}.{{.Name}}"


class {{.Name}}ClientSync(ConnecpyClientSync):{{range .Methods}}
    def {{.Name}}(
        self,
        request: {{if .RequestStream}}Iterator[{{end}}{{.InputType}}{{if .RequestStream}}]{{end}},
        *,
        headers: Headers | Mapping[str, str] | None = None,
        timeout_ms: int | None = None,
        {{if .NoSideEffects}}use_get: bool = False,{{end}}
    ) -> {{if .ResponseStream}}ResponseStreamSync[{{.OutputType}}]{{else}}{{.OutputType}}{{end}}:
        {{if .Stream -}}
        res = self._make_request_stream(
            url="/{{.Package}}.{{.ServiceName}}/{{.Name}}",
            headers=headers,
            request=request,
            timeout_ms=timeout_ms,
            response_class={{.OutputType}},
        )
        {{if .ResponseStream -}}
        return res
        {{else -}}
        return self._consume_single_response(res)
        {{end}}
        {{else -}}
        return self._make_request(
            url="/{{.Package}}.{{.ServiceName}}/{{.Name}}",
            method={{if .NoSideEffects}}"GET" if use_get else "POST"{{else}}"POST"{{end}},
            headers=headers,
            timeout_ms=timeout_ms,
            request=request,
            response_class={{.OutputType}},
        )
        {{end}}
{{end}}{{end}}`))
