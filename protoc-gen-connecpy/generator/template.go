package generator

import "text/template"

type ImportStatement struct {
	Name     string
	Alias    string
	Relative bool
	IsLocal  bool // true for local imports (like example.*), false for third-party (like google.*)
}

type ConnecpyTemplateVariables struct {
	FileName     string
	ModuleName   string
	Imports      []ImportStatement
	Services     []*ConnecpyService
	TransportAPI bool // Whether to generate Transport API support
}

type ConnecpyService struct {
	Package  string
	Name     string
	FullName string
	Comment  string
	Methods  []*ConnecpyMethod
}

type ConnecpyMethod struct {
	Package          string
	ServiceName      string
	Name             string
	PythonName       string
	Comment          string
	InputType        string
	OutputType       string
	EndpointType     string
	IdempotencyLevel string
	Stream           bool
	RequestStream    bool
	ResponseStream   bool
	NoSideEffects    bool
}

// ConnecpyTemplate - Template for connecpy server and client
var ConnecpyTemplate = template.Must(template.New("ConnecpyTemplate").Parse(`# Generated by https://github.com/i2y/connecpy/v2/protoc-gen-connecpy.  DO NOT EDIT!
# source: {{.FileName}}
{{if .Services}}{{if .TransportAPI}}
from __future__ import annotations

import importlib
{{end}}from collections.abc import AsyncIterator, Iterable, Iterator, Mapping  # noqa: TC003
from typing import TYPE_CHECKING, ClassVar, Protocol
{{- range .Imports }}
{{- if not .IsLocal }}

{{if .Relative}}from . import {{.Name}}{{else}}import {{.Name}}{{end}} as {{.Alias}}
{{- end}}
{{- end}}
from connecpy.client import ConnecpyClient, ConnecpyClientSync
from connecpy.code import Code
from connecpy.exceptions import ConnecpyException
from connecpy.interceptor import Interceptor, InterceptorSync  # noqa: TC001
from connecpy.method import IdempotencyLevel, MethodInfo
from connecpy.request import Headers, RequestContext  # noqa: TC001
from connecpy.server import (
    ConnecpyASGIApplication,
    ConnecpyWSGIApplication,
    Endpoint,
    EndpointSync,
)
{{- range .Imports }}
{{- if .IsLocal }}

{{if .Relative}}from . import {{.Name}}{{else}}import {{.Name}}{{end}} as {{.Alias}}
{{- end}}
{{- end}}
{{- end}}
{{- if .TransportAPI}}

if TYPE_CHECKING:
    from connecpy.transport.client.connect import ConnectTransport
    from connecpy.transport.client.connect_async import ConnectTransportAsync
    from connecpy.transport.client.grpc import GrpcTransport
    from connecpy.transport.client.grpc_async import GrpcTransportAsync
{{- end}}
{{- range .Services}}


class {{.Name}}(Protocol):
    """Service protocol for {{.Name}}."""

    _service_info: ClassVar[dict] = {
        "name": "{{.FullName}}",
        "methods": { {{- range .Methods }}
            "{{.PythonName}}": MethodInfo(
                name="{{.Name}}",
                service_name="{{.ServiceName}}",
                input={{.InputType}},
                output={{.OutputType}},
                idempotency_level=IdempotencyLevel.{{.IdempotencyLevel}},
            ),{{- end }}
        }
    }
    {{- range .Methods }}
    {{if not .ResponseStream }}async {{end}}def {{.PythonName}}(self, request: {{if .RequestStream}}AsyncIterator[{{end}}{{.InputType}}{{if .RequestStream}}]{{end}}, ctx: RequestContext) -> {{if .ResponseStream}}AsyncIterator[{{end}}{{.OutputType}}{{if .ResponseStream}}]{{end}}:
        raise ConnecpyException(Code.UNIMPLEMENTED, "Not implemented")
{{ end }}

class {{.Name}}ASGIApplication(ConnecpyASGIApplication):
    def __init__(self, service: {{.Name}}, *, interceptors: Iterable[Interceptor]=(), read_max_bytes: int | None = None) -> None:
        super().__init__(
            endpoints={ {{- range .Methods }}
                "/{{.ServiceName}}/{{.Name}}": Endpoint.{{.EndpointType}}(
                    method=MethodInfo(
                        name="{{.Name}}",
                        service_name="{{.ServiceName}}",
                        input={{.InputType}},
                        output={{.OutputType}},
                        idempotency_level=IdempotencyLevel.{{.IdempotencyLevel}},
                    ),
                    function=service.{{.PythonName}},
                ),{{- end }}
            },
            interceptors=interceptors,
            read_max_bytes=read_max_bytes,
        )

    @property
    def path(self) -> str:
        """Returns the URL path to mount the application to when serving multiple applications."""
        return "/{{.FullName}}"


class {{.Name}}Client(ConnecpyClient):{{range .Methods}}
    {{if not .ResponseStream}}async {{end}}def {{.PythonName}}(
        self,
        request: {{if .RequestStream}}AsyncIterator[{{end}}{{.InputType}}{{if .RequestStream}}]{{end}},
        *,
        headers: Headers | Mapping[str, str] | None = None,
        timeout_ms: int | None = None,
        {{- if .NoSideEffects}}
        use_get: bool = False,
        {{- end}}
    ) -> {{if .ResponseStream}}AsyncIterator[{{.OutputType}}]{{else}}{{.OutputType}}{{end}}:
        return {{if not .ResponseStream }}await {{end}}self.execute_{{.EndpointType}}(
            request=request,
            method=MethodInfo(
                name="{{.Name}}",
                service_name="{{.ServiceName}}",
                input={{.InputType}},
                output={{.OutputType}},
                idempotency_level=IdempotencyLevel.{{.IdempotencyLevel}},
            ),
            headers=headers,
            timeout_ms=timeout_ms,
            {{- if .NoSideEffects}}
            use_get=use_get,
            {{- end}}
        )
{{end}}{{- end }}
{{range .Services}}
class {{.Name}}Sync(Protocol):
    """Synchronous service protocol for {{.Name}}."""

    _service_info: ClassVar[dict] = {
        "name": "{{.FullName}}",
        "methods": { {{- range .Methods }}
            "{{.PythonName}}": MethodInfo(
                name="{{.Name}}",
                service_name="{{.ServiceName}}",
                input={{.InputType}},
                output={{.OutputType}},
                idempotency_level=IdempotencyLevel.{{.IdempotencyLevel}},
            ),{{- end }}
        }
    }
    {{- range .Methods }}
    def {{.PythonName}}(self, request: {{if .RequestStream}}Iterator[{{end}}{{.InputType}}{{if .RequestStream}}]{{end}}, ctx: RequestContext) -> {{if .ResponseStream}}Iterator[{{end}}{{.OutputType}}{{if .ResponseStream}}]{{end}}:
        raise ConnecpyException(Code.UNIMPLEMENTED, "Not implemented")
{{- end }}


class {{.Name}}WSGIApplication(ConnecpyWSGIApplication):
    def __init__(self, service: {{.Name}}Sync, interceptors: Iterable[InterceptorSync]=(), read_max_bytes: int | None = None) -> None:
        super().__init__(
            endpoints={ {{- range .Methods }}
                "/{{.ServiceName}}/{{.Name}}": EndpointSync.{{.EndpointType}}(
                    method=MethodInfo(
                        name="{{.Name}}",
                        service_name="{{.ServiceName}}",
                        input={{.InputType}},
                        output={{.OutputType}},
                        idempotency_level=IdempotencyLevel.{{.IdempotencyLevel}},
                    ),
                    function=service.{{.PythonName}},
                ),{{- end }}
            },
            interceptors=interceptors,
            read_max_bytes=read_max_bytes,
        )

    @property
    def path(self) -> str:
        """Returns the URL path to mount the application to when serving multiple applications."""
        return "/{{.FullName}}"


class {{.Name}}ClientSync(ConnecpyClientSync):{{range .Methods}}
    def {{.PythonName}}(
        self,
        request: {{if .RequestStream}}Iterator[{{end}}{{.InputType}}{{if .RequestStream}}]{{end}},
        *,
        headers: Headers | Mapping[str, str] | None = None,
        timeout_ms: int | None = None,
        {{- if .NoSideEffects}}
        use_get: bool = False,
        {{- end}}
    ) -> {{if .ResponseStream}}Iterator[{{.OutputType}}]{{else}}{{.OutputType}}{{end}}:
        return self.execute_{{.EndpointType}}(
            request=request,
            method=MethodInfo(
                name="{{.Name}}",
                service_name="{{.ServiceName}}",
                input={{.InputType}},
                output={{.OutputType}},
                idempotency_level=IdempotencyLevel.{{.IdempotencyLevel}},
            ),
            headers=headers,
            timeout_ms=timeout_ms,
            {{- if .NoSideEffects}}
            use_get=use_get,
            {{- end}}
        )
{{end}}{{if $.TransportAPI}}

# Client Protocol types for type-safe transport API
class {{.Name}}ClientProtocol(Protocol):
    """Protocol defining the client interface for {{.Name}}."""
    {{- range .Methods}}
    {{if not .ResponseStream}}async {{end}}def {{.PythonName}}(
        self,
        request: {{if .RequestStream}}AsyncIterator[{{end}}{{.InputType}}{{if .RequestStream}}]{{end}},
        *,
        headers: Mapping[str, str] | None = None,
        timeout_ms: int | None = None,
        {{- if .NoSideEffects}}
        use_get: bool = False,
        {{- end}}
    ) -> {{if .ResponseStream}}AsyncIterator[{{.OutputType}}]{{else}}{{.OutputType}}{{end}}: ...
{{- end}}


class {{.Name}}ClientSyncProtocol(Protocol):
    """Protocol defining the synchronous client interface for {{.Name}}."""
    {{- range .Methods}}
    def {{.PythonName}}(
        self,
        request: {{if .RequestStream}}Iterator[{{end}}{{.InputType}}{{if .RequestStream}}]{{end}},
        *,
        headers: Mapping[str, str] | None = None,
        timeout_ms: int | None = None,
        {{- if .NoSideEffects}}
        use_get: bool = False,
        {{- end}}
    ) -> {{if .ResponseStream}}Iterator[{{.OutputType}}]{{else}}{{.OutputType}}{{end}}: ...
{{- end}}


class {{.Name}}GrpcWrapper:
    """Async gRPC stub wrapper implementing {{.Name}}ClientProtocol."""

    def __init__(self, stub: object) -> None:
        """Initialize with a gRPC async stub."""
        self._stub = stub
    {{- range .Methods}}

    {{if not .ResponseStream}}async {{end}}def {{.PythonName}}(
        self,
        request: {{if .RequestStream}}AsyncIterator[{{end}}{{.InputType}}{{if .RequestStream}}]{{end}},
        *,
        headers: Mapping[str, str] | None = None,
        timeout_ms: int | None = None,
        {{- if .NoSideEffects}}
        use_get: bool = False,
        {{- end}}
    ) -> {{if .ResponseStream}}AsyncIterator[{{.OutputType}}]{{else}}{{.OutputType}}{{end}}:
        """Call {{.Name}} via gRPC."""
        metadata = [(k.lower(), v) for k, v in (headers or {}).items()]
        timeout = timeout_ms / 1000.0 if timeout_ms else None
        {{- if .RequestStream}}
        # Client streaming or bidi streaming
        {{- if .ResponseStream}}
        # Bidi streaming - return the stream directly
        return self._stub.{{.Name}}(request, metadata=metadata, timeout=timeout)
        {{- else}}
        # Client streaming - await the result
        return await self._stub.{{.Name}}(request, metadata=metadata, timeout=timeout)
        {{- end}}
        {{- else}}{{- if .ResponseStream}}
        # Server streaming - return the stream directly
        return self._stub.{{.Name}}(request, metadata=metadata, timeout=timeout)
        {{- else}}
        # Unary - await the result
        return await self._stub.{{.Name}}(request, metadata=metadata, timeout=timeout)
        {{- end}}{{- end}}
    {{- end}}


class {{.Name}}GrpcWrapperSync:
    """Sync gRPC stub wrapper implementing {{.Name}}ClientSyncProtocol."""

    def __init__(self, stub: object) -> None:
        """Initialize with a gRPC sync stub."""
        self._stub = stub
    {{- range .Methods}}

    def {{.PythonName}}(
        self,
        request: {{if .RequestStream}}Iterator[{{end}}{{.InputType}}{{if .RequestStream}}]{{end}},
        *,
        headers: Mapping[str, str] | None = None,
        timeout_ms: int | None = None,
        {{- if .NoSideEffects}}
        use_get: bool = False,
        {{- end}}
    ) -> {{if .ResponseStream}}Iterator[{{.OutputType}}]{{else}}{{.OutputType}}{{end}}:
        """Call {{.Name}} via gRPC."""
        metadata = [(k.lower(), v) for k, v in (headers or {}).items()]
        timeout = timeout_ms / 1000.0 if timeout_ms else None
        return self._stub.{{.Name}}(request, metadata=metadata, timeout=timeout)
    {{- end}}


def create_client(
    transport: ConnectTransportAsync | GrpcTransportAsync,
) -> {{.Name}}ClientProtocol:
    """Create an async {{.Name}} client with the specified transport.

    Args:
        transport: The transport to use (ConnectTransportAsync or GrpcTransportAsync)

    Returns:
        A client implementing {{.Name}}ClientProtocol
    """
    # Avoid circular imports by importing here
    from connecpy.transport.client.connect_async import ConnectTransportAsync  # noqa: PLC0415, I001
    from connecpy.transport.client.grpc_async import GrpcTransportAsync  # noqa: PLC0415

    if isinstance(transport, ConnectTransportAsync):
        return {{.Name}}Client(
            address=transport.address,
            proto_json=transport.proto_json,
            accept_compression=transport.accept_compression,
            send_compression=transport.send_compression,
            timeout_ms=transport.timeout_ms,
            read_max_bytes=transport.read_max_bytes,
            interceptors=transport.interceptors,
            session=transport.session,
        )
    if isinstance(transport, GrpcTransportAsync):
        # Import grpc stub
        module_parts = __name__.split(".")
        if module_parts[-1].endswith("_connecpy"):
            base_name = module_parts[-1][:-9]  # Remove "_connecpy"
            module_parts[-1] = f"{base_name}_pb2_grpc"
            grpc_module_name = ".".join(module_parts)
        else:
            grpc_module_name = f"{__name__}_pb2_grpc"

        try:
            grpc_mod = importlib.import_module(grpc_module_name)
        except ImportError as e:
            error_msg = (
                f"Failed to import gRPC stub module '{grpc_module_name}'. "
                f"Make sure you generated the gRPC stubs using: "
                f"python -m grpc_tools.protoc --grpc_python_out=. yourfile.proto"
            )
            raise ImportError(error_msg) from e

        try:
            stub_class = getattr(grpc_mod, "{{.Name}}Stub")  # noqa: B009
        except AttributeError as e:
            error_msg = (
                f"Could not find {{.Name}}Stub in '{grpc_module_name}'. "
                f"This usually means the proto file was not compiled with gRPC support."
            )
            raise AttributeError(error_msg) from e

        stub = stub_class(transport._channel)  # noqa: SLF001
        return {{.Name}}GrpcWrapper(stub)

    error_msg = f"Unsupported transport type: {type(transport)}"
    raise TypeError(error_msg)


def create_client_sync(
    transport: ConnectTransport | GrpcTransport,
) -> {{.Name}}ClientSyncProtocol:
    """Create a sync {{.Name}} client with the specified transport.

    Args:
        transport: The transport to use (ConnectTransport or GrpcTransport)

    Returns:
        A client implementing {{.Name}}ClientSyncProtocol
    """
    # Avoid circular imports by importing here
    from connecpy.transport.client.connect import ConnectTransport  # noqa: PLC0415, I001
    from connecpy.transport.client.grpc import GrpcTransport  # noqa: PLC0415

    if isinstance(transport, ConnectTransport):
        return {{.Name}}ClientSync(
            address=transport.address,
            proto_json=transport.proto_json,
            accept_compression=transport.accept_compression,
            send_compression=transport.send_compression,
            timeout_ms=transport.timeout_ms,
            read_max_bytes=transport.read_max_bytes,
            interceptors=transport.interceptors,
            session=transport.session,
        )
    if isinstance(transport, GrpcTransport):
        # Import grpc stub
        module_parts = __name__.split(".")
        if module_parts[-1].endswith("_connecpy"):
            base_name = module_parts[-1][:-9]  # Remove "_connecpy"
            module_parts[-1] = f"{base_name}_pb2_grpc"
            grpc_module_name = ".".join(module_parts)
        else:
            grpc_module_name = f"{__name__}_pb2_grpc"

        try:
            grpc_mod = importlib.import_module(grpc_module_name)
        except ImportError as e:
            error_msg = (
                f"Failed to import gRPC stub module '{grpc_module_name}'. "
                f"Make sure you generated the gRPC stubs using: "
                f"python -m grpc_tools.protoc --grpc_python_out=. yourfile.proto"
            )
            raise ImportError(error_msg) from e

        try:
            stub_class = getattr(grpc_mod, "{{.Name}}Stub")  # noqa: B009
        except AttributeError as e:
            error_msg = (
                f"Could not find {{.Name}}Stub in '{grpc_module_name}'. "
                f"This usually means the proto file was not compiled with gRPC support."
            )
            raise AttributeError(error_msg) from e

        stub = stub_class(transport._channel)  # noqa: SLF001
        return {{.Name}}GrpcWrapperSync(stub)

    error_msg = f"Unsupported transport type: {type(transport)}"
    raise TypeError(error_msg)
{{- end}}{{- end}}
`))
