package generator

import "text/template"

type ImportStatement struct {
	Name     string
	Alias    string
	Relative bool
}

type ConnectTemplateVariables struct {
	FileName   string
	ModuleName string
	Imports    []ImportStatement
	Services   []*ConnectService
}

type ConnectService struct {
	Package  string
	Name     string
	FullName string
	Comment  string
	Methods  []*ConnectMethod
}

type ConnectMethod struct {
	Package          string
	ServiceName      string
	Name             string
	PythonName       string
	Comment          string
	InputType        string
	OutputType       string
	EndpointType     string
	IdempotencyLevel string
	Stream           bool
	RequestStream    bool
	ResponseStream   bool
	NoSideEffects    bool
}

// ConnectTemplate - Template for Connect server and client
var ConnectTemplate = template.Must(template.New("ConnectTemplate").Parse(`# -*- coding: utf-8 -*-
# Generated by https://github.com/connectrpc/connect-python.  DO NOT EDIT!
# source: {{.FileName}}
{{if .Services}}
from collections.abc import AsyncIterator, Iterable, Iterator, Mapping
from typing import Protocol

from connectrpc.client import ConnectClient, ConnectClientSync
from connectrpc.code import Code
from connectrpc.errors import ConnectError
from connectrpc.interceptor import Interceptor, InterceptorSync
from connectrpc.method import IdempotencyLevel, MethodInfo
from connectrpc.request import Headers, RequestContext
from connectrpc.server import ConnectASGIApplication, ConnectWSGIApplication, Endpoint, EndpointSync

{{- range .Imports }}
{{if .Relative}}from . import {{.Name}}{{else}}import {{.Name}}{{end}} as {{.Alias}}
{{- end}}
{{- end}}
{{- range .Services}}


class {{.Name}}(Protocol):{{- range .Methods }}
    {{if not .ResponseStream }}async {{end}}def {{.PythonName}}(self, request: {{if .RequestStream}}AsyncIterator[{{end}}{{.InputType}}{{if .RequestStream}}]{{end}}, ctx: RequestContext) -> {{if .ResponseStream}}AsyncIterator[{{end}}{{.OutputType}}{{if .ResponseStream}}]{{end}}:
        raise ConnectError(Code.UNIMPLEMENTED, "Not implemented")
{{ end }}

class {{.Name}}ASGIApplication(ConnectASGIApplication):
    def __init__(self, service: {{.Name}}, *, interceptors: Iterable[Interceptor]=(), read_max_bytes: int | None = None) -> None:
        super().__init__(
            endpoints={ {{- range .Methods }}
                "/{{.ServiceName}}/{{.Name}}": Endpoint.{{.EndpointType}}(
                    method=MethodInfo(
                        name="{{.Name}}",
                        service_name="{{.ServiceName}}",
                        input={{.InputType}},
                        output={{.OutputType}},
                        idempotency_level=IdempotencyLevel.{{.IdempotencyLevel}},
                    ),
                    function=service.{{.PythonName}},
                ),{{- end }}
            },
            interceptors=interceptors,
            read_max_bytes=read_max_bytes,
        )

    @property
    def path(self) -> str:
        """Returns the URL path to mount the application to when serving multiple applications."""
        return "/{{.FullName}}"


class {{.Name}}Client(ConnectClient):{{range .Methods}}
    {{if not .ResponseStream}}async {{end}}def {{.PythonName}}(
        self,
        request: {{if .RequestStream}}AsyncIterator[{{end}}{{.InputType}}{{if .RequestStream}}]{{end}},
        *,
        headers: Headers | Mapping[str, str] | None = None,
        timeout_ms: int | None = None,
        {{- if .NoSideEffects}}
        use_get: bool = False,
        {{- end}}
    ) -> {{if .ResponseStream}}AsyncIterator[{{.OutputType}}]{{else}}{{.OutputType}}{{end}}:
        return {{if not .ResponseStream }}await {{end}}self.execute_{{.EndpointType}}(
            request=request,
            method=MethodInfo(
                name="{{.Name}}",
                service_name="{{.ServiceName}}",
                input={{.InputType}},
                output={{.OutputType}},
                idempotency_level=IdempotencyLevel.{{.IdempotencyLevel}},
            ),
            headers=headers,
            timeout_ms=timeout_ms,
            {{- if .NoSideEffects}}
            use_get=use_get,
            {{- end}}
        )
{{end}}{{- end }}
{{range .Services}}
class {{.Name}}Sync(Protocol):{{- range .Methods }}
    def {{.PythonName}}(self, request: {{if .RequestStream}}Iterator[{{end}}{{.InputType}}{{if .RequestStream}}]{{end}}, ctx: RequestContext) -> {{if .ResponseStream}}Iterator[{{end}}{{.OutputType}}{{if .ResponseStream}}]{{end}}:
        raise ConnectError(Code.UNIMPLEMENTED, "Not implemented")
{{- end }}


class {{.Name}}WSGIApplication(ConnectWSGIApplication):
    def __init__(self, service: {{.Name}}Sync, interceptors: Iterable[InterceptorSync]=(), read_max_bytes: int | None = None) -> None:
        super().__init__(
            endpoints={ {{- range .Methods }}
                "/{{.ServiceName}}/{{.Name}}": EndpointSync.{{.EndpointType}}(
                    method=MethodInfo(
                        name="{{.Name}}",
                        service_name="{{.ServiceName}}",
                        input={{.InputType}},
                        output={{.OutputType}},
                        idempotency_level=IdempotencyLevel.{{.IdempotencyLevel}},
                    ),
                    function=service.{{.PythonName}},
                ),{{- end }}
            },
            interceptors=interceptors,
            read_max_bytes=read_max_bytes,
        )

    @property
    def path(self) -> str:
        """Returns the URL path to mount the application to when serving multiple applications."""
        return "/{{.FullName}}"


class {{.Name}}ClientSync(ConnectClientSync):{{range .Methods}}
    def {{.PythonName}}(
        self,
        request: {{if .RequestStream}}Iterator[{{end}}{{.InputType}}{{if .RequestStream}}]{{end}},
        *,
        headers: Headers | Mapping[str, str] | None = None,
        timeout_ms: int | None = None,
        {{- if .NoSideEffects}}
        use_get: bool = False,
        {{- end}}
    ) -> {{if .ResponseStream}}Iterator[{{.OutputType}}]{{else}}{{.OutputType}}{{end}}:
        return self.execute_{{.EndpointType}}(
            request=request,
            method=MethodInfo(
                name="{{.Name}}",
                service_name="{{.ServiceName}}",
                input={{.InputType}},
                output={{.OutputType}},
                idempotency_level=IdempotencyLevel.{{.IdempotencyLevel}},
            ),
            headers=headers,
            timeout_ms=timeout_ms,
            {{- if .NoSideEffects}}
            use_get=use_get,
            {{- end}}
        )
{{end}}{{end}}`))
